// Assuming uni-app types are available, otherwise you might need to declare the 'uni' object.
// For example, create a file `uni.d.ts` with:
// declare const uni: any;

// --- Interface Definitions for Type Safety ---

/**
 * Basic metadata for a book.
 */
interface BookMetadata {
  bookId: number;
  isMarketAvailable?: boolean; // Optional as it might not be relevant for all contexts
  title: string;
  author: string;
  tags: string[];
  summary: string;
  reader: string;
  cover: string;
}

/**
 * User-specific metadata and progress for a book.
 */
interface ReaderMetadata {
  bookId: number;
  version: number; // current active version
  readTime: number; // total reading time in seconds across all versions
  lastReadSentenceId: { [version: number]: number }; // maps version to last read sentence ID for that version
  lastReadScroll: { [version: number]: number }; // maps version to last read scroll position for that version
  isAudioPlaying: boolean;
  customTitle: string | null;
  customSummary: string | null;
  customTags: string[];
}

/**
 * A single sentence within a book's content.
 */
interface Sentence {
  sentenceId: number;
  version: number;
  content: string;
}

/**
 * The main content of a book, consisting of sentences.
 */
interface BookContent {
  bookId: number;
  sentences: Sentence[];
}

/**
 * Audio data for a single sentence.
 */
interface AudioData {
  sentenceId: number;
  version: number;
  audio: string | null; // Base64 data URI or null
}

/**
 * Container for all audio data of a book.
 */
interface BookAudio {
  bookId: number;
  audioData: AudioData[];
}

/**
 * Represents a single version of a book.
 * even each in-progress AI task is a version, regardless of its completion status, or deleted.
 */
interface Version {
  version: number;
  taskName: string;
  versionCreatedAt: string;
  isAiTaskInProgress: boolean;
}

/**
 * Represents a running AI task for generating a new version.
 */
interface AITask {
  id: string;
  name: string;
  progress: number;
  newVersionId: number;
  parentVersionId: number;
}

/**
 * Manages all versions and running AI tasks for a book.
 */
interface BookVersions {
  bookId: number;
  currentVersionId: number;
  runningAiTasks: AITask[];
  allVersions: Version[];
}

/**
 * A comprehensive object representing all data for a single book.
 */
interface ComprehensiveBook {
  metadata: BookMetadata;
  readerMetadata: ReaderMetadata;
  content: BookContent;
  versions: BookVersions;
  audio: BookAudio;
}

// Defines the possible types for storage keys.
type StorageKeyType = 'metadata' | 'readerMetadata' | 'data' | 'versions' | 'audio';
type ListStorageKey = 'all_books' | 'market_books' | 'library_books';


/**
 * A service to manage book content storage using uni-app's storage API.
 * The data is structured into five distinct parts:
 * - book.metadata (title, author, summary, etc.)
 * - book.readerMetadata (last read position, custom fields, etc.)
 * - book.content (sentences)
 * - book.versions (version history)
 * - book.audio (audio data for sentences)
 * It also manages lists of all available books, market books, and user's library books.
 */
class BookCacheService {

  // --- Key Definitions ---
  private getStorageKey(bookId: number, type: StorageKeyType): string;
  private getStorageKey(bookId: null, type: ListStorageKey): string;
  private getStorageKey(bookId: number | null, type: StorageKeyType | ListStorageKey): string {
    switch (type) {
      case 'metadata':
        return `book_metadata_${bookId}`;
      case 'readerMetadata':
        return `book_reader_metadata_${bookId}`;
      case 'data':
        return `book_content_${bookId}`;
      case 'versions':
        return `book_all_version_${bookId}`;
      case 'audio':
        return `book_audio_${bookId}`;
      default:
        // For lists that are not book-specific (e.g., 'all_books')
        return type;
    }
  }

  // --- Utility and ID Generation ---
  private generateNewBookId(): number {
    const allBooks = this.getAllBooks();
    if (!allBooks || allBooks.length === 0) {
      return 1;
    }
    const maxId = allBooks.reduce((max, book) => Math.max(max, book.bookId), 0);
    return maxId + 1;
  }


  // --- Mock Data Creation ---

  /**
   * Creates the initial lists of books for the app with basic metadata.
   * REWRITTEN LOGIC: The marketBooks list is now dynamically generated from allBooks
   * based on the `isMarketAvailable` flag.
   */
  private createInitialBookLists(): {
    allBooks: BookMetadata[],
    marketBooks: number[],
    libraryBooks: number[]
  } {
    const allBooks: BookMetadata[] = [{
      bookId: 1,
      isMarketAvailable: true,
      title: "The First Adventure",
      author: "AI Author",
      tags: ["Fantasy", "AI", "Adventure"],
      summary: "A thrilling tale of a hero's first journey into a world of magic and machines.",
      reader: "Professional Narrator",
      cover: "/static/covers/cover1.png",
    }, {
      bookId: 2,
      isMarketAvailable: true,
      title: "Journey to the Unknown",
      author: "AI Author",
      tags: ["Sci-Fi", "Mystery"],
      summary: "An epic saga that explores the vast, unknown regions of the galaxy.",
      reader: "AI Voice",
      cover: "/static/covers/cover2.png",
    }, {
      bookId: 3,
      isMarketAvailable: false,
      title: "Secrets of the Old Forest",
      author: "Nature Scribe",
      tags: ["Nature", "Mystery"],
      summary: "A hidden world of secrets is discovered in an ancient forest.",
      reader: "AI Voice",
      cover: "/static/covers/cover3.png",
    }, {
	  bookId: 4,
	  isMarketAvailable: true,
	  title: "Cybernetic Dreams",
	  author: "Synth Weaver",
	  tags: ["Cyberpunk", "Sci-Fi"],
	  summary: "In a neon-drenched future, a detective hunts for a rogue AI.",
	  reader: "Professional Narrator",
	  cover: "/static/covers/cover1.png", 
	}, {
	  bookId: 5,
	  isMarketAvailable: true,
	  title: "The Last Spell",
	  author: "Mage Chronicler",
	  tags: ["Fantasy", "Magic"],
	  summary: "The story of the final spell that changed the world forever.",
	  reader: "AI Voice",
	  cover: "/static/covers/cover2.png",
	}];

    // Relevant Logic: Only books where isMarketAvailable is true shall be in marketBooks.
    const marketBooks: number[] = allBooks
      .filter(book => book.isMarketAvailable)
      .map(book => book.bookId);

    // Add book 1 and 3 to the library by default for testing.
    const libraryBooks: number[] = [1, 3]; 

    console.log("[BookCacheService] Created initial book lists:", {
        allBooksCount: allBooks.length,
        marketBooks: marketBooks,
        libraryBooks: libraryBooks
    });

    return {
      allBooks,
      marketBooks,
      libraryBooks
    };
  }


  /**
   * Creates mock reader metadata for a single book.
   */
  private createMockReaderMetadata(bookId: number): ReaderMetadata {
    return {
      bookId: bookId,
      version: 1, // Default to reading the first version
      readTime: 0, // Total reading time in seconds across all versions
      lastReadSentenceId: { 1: 0 }, // Default to sentence 0 for version 1
      lastReadScroll: { 1: 0 }, // Default to 0% scroll for version 1
      isAudioPlaying: false,
      // New customizable fields
      customTitle: null,
      customSummary: null,
      customTags: [],
    };
  }

  /**
   * Creates detailed mock data for a single book's content.
   */
  private createMockBookDetailData(bookId: number): {
    bookData: BookContent,
    bookAllVersion: BookVersions,
    BookAudio: BookAudio
  } {
    // A short, silent WAV file encoded in Base64. This is a playable data URI.
    const silentAudioBase64 = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';

    const bookData: BookContent = {
      bookId: bookId,
      sentences: []
    };
    const bookAllVersion: BookVersions = {
      bookId: bookId,
      currentVersionId: 2,
      runningAiTasks: [], // Holds the full details of any running tasks
      allVersions: [{
        version: 1,
        taskName: "Initial Version",
        versionCreatedAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
        isAiTaskInProgress: false
      }, {
        version: 2,
        taskName: "AI Enhanced Version",
        versionCreatedAt: new Date().toISOString(),
        isAiTaskInProgress: false
      }, ]
    };
    const BookAudio: BookAudio = {
      bookId: bookId,
      audioData: []
    };

    let sentenceIdCounter = 0;

    // --- Version 1 Content ---
    const version1Content = "This is the original version of the book. It tells a simple tale. ";
    for (let i = 0; i < 150; i++) {
      const sentenceId = sentenceIdCounter++;
      bookData.sentences.push({
        sentenceId: sentenceId,
        version: 1,
        content: `${i + 1}. ${version1Content}`
      });
      BookAudio.audioData.push({
        sentenceId: sentenceId,
        version: 1,
        audio: silentAudioBase64
      });
    }

    // --- Version 2 Content (An AI-modified version) ---
    const version2Content = "This is the AI-enhanced version of the book, with a more elaborate and descriptive narrative. ";
    for (let i = 0; i < 200; i++) {
      const sentenceId = sentenceIdCounter++;
      bookData.sentences.push({
        sentenceId: sentenceId,
        version: 2,
        content: `${i + 1}. ${version2Content}`
      });
      BookAudio.audioData.push({
        sentenceId: sentenceId,
        version: 2,
        audio: silentAudioBase64
      });
    }

    return {
      bookData,
      bookAllVersion,
      BookAudio
    };
  }

  // --- Getters for Book Lists ---

  public getAllBooks(): BookMetadata[] {
    const storageKey = this.getStorageKey(null, 'all_books');
    try {
      const allBooks = uni.getStorageSync(storageKey) as BookMetadata[];
      if (allBooks && allBooks.length) {
        return allBooks;
      } else {
        // Create and save initial book lists and their metadata
        const initialData = this.createInitialBookLists();
        this.saveAllBooks(initialData.allBooks);
        this.saveMarketBooks(initialData.marketBooks);
        this.saveLibraryBooks(initialData.libraryBooks);

        // Also create mock details and metadata for the initial books
        initialData.allBooks.forEach(book => {
          this.getBookContentById(book.bookId); // Creates content
          this.getBookMetadata(book.bookId); // Creates metadata
          this.getReaderMetadata(book.bookId); // Creates reader metadata
        });
        return initialData.allBooks;
      }
    } catch (e) {
      console.error('Failed to get all books from storage:', e);
      return [];
    }
  }

  public getMarketBooks(): number[] {
    const storageKey = this.getStorageKey(null, 'market_books');
    try {
      const marketBooks = uni.getStorageSync(storageKey) as number[];
      if (marketBooks && marketBooks.length) {
        return marketBooks;
      } else {
        const initialData = this.createInitialBookLists();
        this.saveMarketBooks(initialData.marketBooks);
        return initialData.marketBooks;
      }
    } catch (e) {
      console.error('Failed to get market books from storage:', e);
      return [];
    }
  }

  public getLibraryBooks(): number[] {
    const storageKey = this.getStorageKey(null, 'library_books');
    try {
      const libraryBooks = uni.getStorageSync(storageKey) as number[];
      // Note: It's okay for library books to be initially empty
      if (libraryBooks) {
        return libraryBooks;
      } else {
        const initialData = this.createInitialBookLists();
        this.saveLibraryBooks(initialData.libraryBooks);
        return initialData.libraryBooks;
      }
    } catch (e) {
      console.error('Failed to get library books from storage:', e);
      return [];
    }
  }

  // --- Savers for Book Lists ---

  public saveAllBooks(allBooks: BookMetadata[]): void {
    const storageKey = this.getStorageKey(null, 'all_books');
    try {
      uni.setStorageSync(storageKey, allBooks);
    } catch (e) {
      console.error('Failed to save all books to storage:', e);
    }
  }

  public saveMarketBooks(marketBooks: number[]): void {
    const storageKey = this.getStorageKey(null, 'market_books');
    try {
      uni.setStorageSync(storageKey, marketBooks);
    } catch (e) {
      console.error('Failed to save market books to storage:', e);
    }
  }

  public saveLibraryBooks(libraryBooks: number[]): void {
    const storageKey = this.getStorageKey(null, 'library_books');
    try {
      uni.setStorageSync(storageKey, libraryBooks);
    } catch (e) {
      console.error('Failed to save library books to storage:', e);
    }
  }


  /**
   * Adds a book from the market to the user's library.
   * Logic: A book can be added to the library if it exists in the market books
   * and is not already in the library. This fulfills the requirement that all
   * market books are okay to add to library books.
   * @param {number} bookId The ID of the book to add.
   * @returns {boolean} True if the book was successfully added, false otherwise.
   */
  public addBookToLibrary(bookId: number): boolean {
    const marketBooks = this.getMarketBooks();
    const libraryBooks = this.getLibraryBooks();

    const isBookInMarket = marketBooks.includes(bookId);
    const isBookAlreadyInLibrary = libraryBooks.includes(bookId);

    if (isBookInMarket && !isBookAlreadyInLibrary) {
			libraryBooks.push(bookId);
			this.saveLibraryBooks(libraryBooks);
      return true;
    } else {
			if (!isBookInMarket) {
				console.warn(`Book with ID ${bookId} is not in the market.`);
			}
			if (isBookAlreadyInLibrary) {
				console.warn(`Book with ID ${bookId} is already in the library.`);
			}
			return false;
		}
  }


  // --- Getters and Savers for Individual Book Parts ---

  /**
   * Gets a book's metadata (title, author, summary, etc.).
   */
  public getBookMetadata(bookId: number): BookMetadata | null {
    const storageKey = this.getStorageKey(bookId, 'metadata');
    try {
      const metadata = uni.getStorageSync(storageKey) as BookMetadata;
      if (metadata) {
        return metadata;
      } else {
        // If not in storage, find it in the main list, save it, and return it
        const allBooks = this.getAllBooks();
        const bookInfo = allBooks.find(b => b.bookId === bookId);
        if (bookInfo) {
          this.saveBookMetadata(bookId, bookInfo);
          return bookInfo;
        }
        return null;
      }
    } catch (e) {
      console.error(`Failed to get metadata for book ${bookId}:`, e);
      return null;
    }
  }

  /**
   * Saves a book's metadata.
   */
  public saveBookMetadata(bookId: number, metadata: BookMetadata): void {
    const storageKey = this.getStorageKey(bookId, 'metadata');
    try {
      uni.setStorageSync(storageKey, metadata);
    } catch (e) {
      console.error(`Failed to save metadata for book ${bookId}:`, e);
    }
  }

  /**
   * Gets a book's reader-specific metadata (progress, audio state, etc.).
   */
  public getReaderMetadata(bookId: number): ReaderMetadata {
    const storageKey = this.getStorageKey(bookId, 'readerMetadata');
    try {
      const readerMetadata = uni.getStorageSync(storageKey) as ReaderMetadata;
      if (readerMetadata) {
        return readerMetadata;
      } else {
        // Create, save, and return default reader metadata
        const defaultData = this.createMockReaderMetadata(bookId);
        this.saveReaderMetadata(bookId, defaultData);
        return defaultData;
      }
    } catch (e) {
      console.error(`Failed to get reader metadata for book ${bookId}:`, e);
      return this.createMockReaderMetadata(bookId); // Return default on error
    }
  }

  /**
   * Saves a book's reader-specific metadata.
   */
  public saveReaderMetadata(bookId: number, readerMetadata: ReaderMetadata): void {
    const storageKey = this.getStorageKey(bookId, 'readerMetadata');
    try {
      uni.setStorageSync(storageKey, readerMetadata);
    } catch (e) {
      console.error(`Failed to save reader metadata for book ${bookId}:`, e);
    }
  }

  /**
   * Gets a book's core content (sentences, versions, audio).
   */
  public getBookContentById(bookId: number): {
    bookData: BookContent,
    bookAllVersion: BookVersions,
    BookAudio: BookAudio
  } {
    try {
      const bookData = uni.getStorageSync(this.getStorageKey(bookId, 'data')) as BookContent;
      const bookAllVersion = uni.getStorageSync(this.getStorageKey(bookId, 'versions')) as BookVersions;
      const BookAudio = uni.getStorageSync(this.getStorageKey(bookId, 'audio')) as BookAudio;

      if (bookData && bookAllVersion && BookAudio) {
        return {
          bookData,
          bookAllVersion,
          BookAudio
        };
      } else {
        console.log(`No data found for book ${bookId}. Creating new mock data.`);
        const mockData = this.createMockBookDetailData(bookId);
        this.saveBookContent(bookId, mockData.bookData, mockData.bookAllVersion, mockData.BookAudio);
        return mockData;
      }
    } catch (e) {
      console.error('Failed to get book data from storage:', e);
      return this.createMockBookDetailData(bookId);
    }
  }

  /**
   * Saves a book's core content (sentences, versions, audio).
   */
  public saveBookContent(bookId: number, bookData: BookContent, bookAllVersion: BookVersions, BookAudio: BookAudio): void {
    try {
      uni.setStorageSync(this.getStorageKey(bookId, 'data'), bookData);
      uni.setStorageSync(this.getStorageKey(bookId, 'versions'), bookAllVersion);
      uni.setStorageSync(this.getStorageKey(bookId, 'audio'), BookAudio);
    } catch (e) {
      console.error('Failed to save book data to storage:', e);
    }
  }

  // --- Comprehensive Getters and Savers for the Whole Book ---

  /**
   * Retrieves and assembles all parts of a book into a single object.
   * @param {number} bookId The ID of the book to retrieve.
   * @returns {ComprehensiveBook | null} A comprehensive book object or null if not found.
   */
  public getBookByBookId(bookId: number): ComprehensiveBook | null {
    const metadata = this.getBookMetadata(bookId);
    if (!metadata) {
      return null; // Book does not exist
    }
    const readerMetadata = this.getReaderMetadata(bookId);
    const {
      bookData,
      bookAllVersion,
      BookAudio
    } = this.getBookContentById(bookId);

    return {
      metadata: metadata,
      readerMetadata: readerMetadata,
      content: bookData,
      versions: bookAllVersion,
      audio: BookAudio,
    };
  }

  /**
   * Saves all parts of a comprehensive book object.
   * @param {ComprehensiveBook} bookObject The complete book object.
   */
  public saveBook(bookObject: ComprehensiveBook): void {
    if (!bookObject?.metadata?.bookId) {
      console.error("Invalid book object provided to saveBook.");
      return;
    }
    const bookId = bookObject.metadata.bookId;

    this.saveBookMetadata(bookId, bookObject.metadata);
    this.saveReaderMetadata(bookId, bookObject.readerMetadata);
    this.saveBookContent(bookId, bookObject.content, bookObject.versions, bookObject.audio);
  }


  // --- AI Task Management ---

  /**
   * Calculates consumption cost based on sentence count
   * @param {number} currentVersionSentences - Number of sentences in current version
   * @param {number} newVersionSentences - Number of sentences in new version (default 0 for cancellation)
   * @param {number} multiplier - Cost multiplier (default 1, 1.3 for acceleration)
   * @returns {number} Calculated cost
   */
  private calculateConsumptionCost(currentVersionSentences: number, newVersionSentences: number = 0, multiplier: number = 1): number {
    const baseCost = (currentVersionSentences + newVersionSentences) * 0.1; // 0.1 cost per sentence
    return Math.ceil(baseCost * multiplier);
  }

  public startAITask(bookId: number, taskName: string = "New AI Task", onConsumeAIBudget?: (details: any) => boolean): void {
    let {
      bookData,
      bookAllVersion,
      BookAudio
    } = this.getBookContentById(bookId);

    // Check if there's already a running task with the same name for the same book
    const existingTask = bookAllVersion.runningAiTasks.find(task => task.name === taskName);
    if (existingTask) {
      console.warn(`AI task "${taskName}" is already running for book ${bookId}`);
      return;
    }

    console.log(`[BookCacheService] Starting AI task: ${taskName} for book ${bookId}`);

    const maxVersionId = bookAllVersion.allVersions.reduce((max, v) => Math.max(max, v.version), 0);
    const newVersionId = maxVersionId + 1;

    // Calculate consumption cost
    const currentVersionSentences = bookData.sentences.filter(s => s.version === bookAllVersion.currentVersionId).length;
    const estimatedNewVersionSentences = Math.max(currentVersionSentences * 0.3, 5); // Estimate 30% more sentences or minimum 5
    const consumptionCost = this.calculateConsumptionCost(currentVersionSentences, estimatedNewVersionSentences);

    // Check and consume AI budget
    if (onConsumeAIBudget) {
      const consumptionSuccess = onConsumeAIBudget({
        aiTask: taskName,
        bookId: bookId,
        version: newVersionId,
        spentAmount: consumptionCost
      });

      if (!consumptionSuccess) {
        console.warn(`Insufficient AI budget for task "${taskName}"`);
        return;
      }
    }

    const currentVersion = bookAllVersion.allVersions.find(v => v.version === bookAllVersion.currentVersionId);
    if (!currentVersion) {
      console.error("Could not find current version to attach AI task.");
      return;
    }

    const taskId = `ai_${Date.now()}`;
    const newTask: AITask = {
      id: taskId,
      name: taskName,
      progress: 0,
      newVersionId: newVersionId,
      parentVersionId: currentVersion.version, // Link task to its parent version
    };

    // Create the new version entry immediately with isAiTaskInProgress: true
    const newVersion: Version = {
      version: newVersionId,
      taskName: taskName,
      versionCreatedAt: new Date().toISOString(),
      isAiTaskInProgress: true
    };

    // Add the new version to allVersions
    bookAllVersion.allVersions.push(newVersion);

    // Add task to the central running list
    bookAllVersion.runningAiTasks.push(newTask);
        
    this.saveBookContent(bookId, bookData, bookAllVersion, BookAudio);

    const intervalId = setInterval(() => {
      let {
        bookData: currentBookData,
        bookAllVersion: currentBookAllVersion,
        BookAudio: currentBookAudio
      } = this.getBookContentById(bookId);

      const taskIndex = currentBookAllVersion.runningAiTasks.findIndex(t => t.id === taskId);
      if (taskIndex === -1) {
        clearInterval(intervalId);
        return;
      }

      let task = currentBookAllVersion.runningAiTasks[taskIndex];
      task.progress += 1;

      if (task.progress >= 100) {
        clearInterval(intervalId);

        const maxSentenceId = currentBookData.sentences.reduce((max, s) => Math.max(max, s.sentenceId), -1);
        let sentenceIdCounter = maxSentenceId + 1;

        const newContent =
          `This is the newly generated content from "${task.name}" for version ${task.newVersionId}. `;
        for (let i = 0; i < 5; i++) {
          const sentenceId = sentenceIdCounter++;
          currentBookData.sentences.push({
            sentenceId: sentenceId,
            version: task.newVersionId,
            content: `${i + 1}. ${newContent}`
          });
          currentBookAudio.audioData.push({
            sentenceId: sentenceId,
            version: task.newVersionId,
            audio: null
          });
        }

        // Remove completed task from the running list
        currentBookAllVersion.runningAiTasks.splice(taskIndex, 1);

        // Update the completed version's status (version already exists from startAITask)
        const completedVersion = currentBookAllVersion.allVersions.find(v => v.version === task.newVersionId);
        if (completedVersion) {
          completedVersion.isAiTaskInProgress = false;
        }

        // Update the parent version's task status
        const taskParentVersion = currentBookAllVersion.allVersions.find(v => v.version === task.parentVersionId);
        if (taskParentVersion) {
          // Check if there are any other running tasks for this parent version
          const remainingTasks = currentBookAllVersion.runningAiTasks.filter(t => t.parentVersionId === task.parentVersionId && t.id !== task.id);
          taskParentVersion.isAiTaskInProgress = remainingTasks.length > 0;
        }

        // Don't change currentVersionId - keep the original current version
        // Users can manually switch to the new version if they want
        
        this.saveBookContent(bookId, currentBookData, currentBookAllVersion, currentBookAudio);
        
        // Emit completion event for UI updates
        uni.$emit('ai-task-completed', {
          bookId: bookId,
          completedVersionId: task.newVersionId,
          taskName: task.name
        });

      } else {
        this.saveBookContent(bookId, currentBookData, currentBookAllVersion, currentBookAudio);
      }
    }, 1000);
  }

  public cancelAITask(bookId: number, taskKey: string, onConsumeAIBudget?: (details: any) => boolean): void {
    let {
      bookData,
      bookAllVersion,
      BookAudio
    } = this.getBookContentById(bookId);

    // Try to find by task ID first (new way), then fall back to old parsing method
    let taskIndex = bookAllVersion.runningAiTasks.findIndex(t => t.id === taskKey);
    
    if (taskIndex === -1) {
      // Fall back to old method for backward compatibility
      const [taskName, versionStr] = taskKey.split('_v');
      const versionId = parseInt(versionStr, 10);
      taskIndex = bookAllVersion.runningAiTasks.findIndex(
        t => t.name === taskName && t.newVersionId === versionId
      );
    }

    if (taskIndex !== -1) {
      const task = bookAllVersion.runningAiTasks[taskIndex];
      console.log(`[BookCacheService] Cancelling AI task: ${task.name} for book ${bookId}`);

      // Calculate and charge cancellation cost (only current version)
      const currentVersionSentences = bookData.sentences.filter(s => s.version === bookAllVersion.currentVersionId).length;
      const cancellationCost = this.calculateConsumptionCost(currentVersionSentences, 0); // No new version cost

      // Log consumption for cancellation
      if (onConsumeAIBudget) {
        onConsumeAIBudget({
          aiTask: `Cancel ${task.name}`,
          bookId: bookId,
          version: task.newVersionId,
          spentAmount: cancellationCost
        });
      }

      // Find the parent version to update its count
      const parentVersion = bookAllVersion.allVersions.find(v => v.version === task.parentVersionId);

      // Remove the task from the running list
      bookAllVersion.runningAiTasks.splice(taskIndex, 1);

      // Remove the in-progress version that was created
      const versionIndex = bookAllVersion.allVersions.findIndex(v => v.version === task.newVersionId);
      if (versionIndex !== -1) {
        bookAllVersion.allVersions.splice(versionIndex, 1);
        console.log(`[BookCacheService] Removed in-progress version ${task.newVersionId}`);
      }

      if (parentVersion) {
        // Check if there are any other running tasks for this parent version
        const remainingTasks = bookAllVersion.runningAiTasks.filter(t => t.parentVersionId === parentVersion.version && t.id !== task.id);
        parentVersion.isAiTaskInProgress = remainingTasks.length > 0;
      }

      this.saveBookContent(bookId, bookData, bookAllVersion, BookAudio);
      
      // Emit cancellation event for UI updates
      uni.$emit('ai-task-cancelled', {
        bookId: bookId,
        cancelledVersionId: task.newVersionId,
        taskName: task.name
      });
    } else {
      console.warn(`[BookCacheService] Task not found for cancellation: ${taskKey}`);
    }
  }

  public accelerateAITask(bookId: number, taskKey: string, onConsumeAIBudget?: (details: any) => boolean): void {
    let {
      bookData,
      bookAllVersion,
      BookAudio
    } = this.getBookContentById(bookId);

    // Try to find by task ID first (new way), then fall back to old parsing method
    let task = bookAllVersion.runningAiTasks.find(t => t.id === taskKey);
    
    if (!task) {
      // Fall back to old method for backward compatibility
      const [taskName, versionStr] = taskKey.split('_v');
      const versionId = parseInt(versionStr, 10);
      task = bookAllVersion.runningAiTasks.find(
        t => t.name === taskName && t.newVersionId === versionId
      );
    }

    if (task) {
      // Calculate and charge acceleration cost (1.3x multiplier)
      const currentVersionSentences = bookData.sentences.filter(s => s.version === bookAllVersion.currentVersionId).length;
      const estimatedNewVersionSentences = Math.max(currentVersionSentences * 0.3, 5);
      const accelerationCost = this.calculateConsumptionCost(currentVersionSentences, estimatedNewVersionSentences, 1.3);

      // Check and consume AI budget for acceleration
      if (onConsumeAIBudget) {
        const consumptionSuccess = onConsumeAIBudget({
          aiTask: `Accelerate ${task.name}`,
          bookId: bookId,
          version: task.newVersionId,
          spentAmount: accelerationCost
        });

        if (!consumptionSuccess) {
          console.warn(`Insufficient AI budget for accelerating task "${task.name}"`);
          return;
        }
      }

      task.progress = Math.min(99, task.progress + 30);
      this.saveBookContent(bookId, bookData, bookAllVersion, BookAudio);
      
      // Emit acceleration event for UI updates
      uni.$emit('ai-task-accelerated', {
        bookId: bookId,
        taskId: task.id,
        newProgress: task.progress,
        taskName: task.name
      });
    }
  }

  // --- Reading Progress Management ---

  /**
   * Updates the reading time for a book (cumulative across all versions).
   * @param bookId The ID of the book
   * @param additionalTime Time to add in seconds
   */
  public updateReadingTime(bookId: number, additionalTime: number): void {
    const readerMetadata = this.getReaderMetadata(bookId);
    if (readerMetadata) {
      readerMetadata.readTime += additionalTime;
      this.saveReaderMetadata(bookId, readerMetadata);
    }
  }

  /**
   * Sets the last read sentence ID for a specific version.
   * This represents where the user is anchored in the library book and should be aligned to audio play reading progress bar.
   * @param bookId The ID of the book
   * @param versionId The version ID
   * @param sentenceId The sentence ID to save as last read position
   */
  public setLastReadPosition(bookId: number, versionId: number, sentenceId: number): void {
    const readerMetadata = this.getReaderMetadata(bookId);
    if (readerMetadata) {
      // Ensure the versionId exists in lastReadSentenceId mapping
      if (!readerMetadata.lastReadSentenceId) {
        readerMetadata.lastReadSentenceId = {};
      }
      readerMetadata.lastReadSentenceId[versionId] = sentenceId;
      this.saveReaderMetadata(bookId, readerMetadata);
      
      console.log(`[BookCacheService] Saved reading position for book ${bookId}, version ${versionId}, sentence ${sentenceId}`);
    }
  }

  /**
   * Sets the last read scroll percentage for a specific version.
   * This saves the scroll percentage to be restored when the user returns.
   * @param bookId The ID of the book
   * @param versionId The version ID
   * @param scrollPercentage The scroll percentage (0-100) to save
   */
  public setLastReadScrollPercentage(bookId: number, versionId: number, scrollPercentage: number): void {
    const readerMetadata = this.getReaderMetadata(bookId);
    if (readerMetadata) {
      // Ensure the versionId exists in lastReadScroll mapping
      if (!readerMetadata.lastReadScroll) {
        readerMetadata.lastReadScroll = {};
      }
      readerMetadata.lastReadScroll[versionId] = Math.min(100, Math.max(0, scrollPercentage));
      this.saveReaderMetadata(bookId, readerMetadata);
      
      console.log(`[BookCacheService] Saved scroll percentage for book ${bookId}, version ${versionId}, percentage ${scrollPercentage.toFixed(1)}%`);
    }
  }

  /**
   * Gets the last read sentence ID for a specific version.
   * This is used to restore the user's reading position when they return to the book.
   * @param bookId The ID of the book
   * @param versionId The version ID
   * @returns The last read sentence ID for that version, or 0 if not found
   */
  public getLastReadPosition(bookId: number, versionId: number): number {
    const readerMetadata = this.getReaderMetadata(bookId);
    if (readerMetadata && readerMetadata.lastReadSentenceId && readerMetadata.lastReadSentenceId[versionId] !== undefined) {
      return readerMetadata.lastReadSentenceId[versionId];
    }
    return 0; // Default to the beginning if no position is saved
  }

  /**
   * Gets the last read scroll percentage for a specific version.
   * This is used to restore the user's scroll position when they return to the book.
   * @param bookId The ID of the book
   * @param versionId The version ID
   * @returns The last read scroll percentage for that version, or 0 if not found
   */
  public getLastReadScrollPercentage(bookId: number, versionId: number): number {
    const readerMetadata = this.getReaderMetadata(bookId);
    if (readerMetadata && readerMetadata.lastReadScroll && readerMetadata.lastReadScroll[versionId] !== undefined) {
      return readerMetadata.lastReadScroll[versionId];
    }
    return 0; // Default to the beginning if no position is saved
  }

  /**
   * Calculates the reading progress percentage for a specific version based on the last read sentence.
   * This aligns with the audio play reading progress bar.
   * @param bookId The ID of the book
   * @param versionId The version ID
   * @returns Progress percentage (0-100)
   */
  public getReadingProgressPercentage(bookId: number, versionId: number): number {
    // First try to get from lastReadScroll which is more accurate
    const scrollPercentage = this.getLastReadScrollPercentage(bookId, versionId);
    if (scrollPercentage > 0) {
      return scrollPercentage;
    }

    // Fallback to sentence-based calculation
    const lastSentenceId = this.getLastReadPosition(bookId, versionId);
    if (lastSentenceId === 0) {
      return 0; // No progress made
    }

    const { bookData } = this.getBookContentById(bookId);
    const versionSentences = bookData.sentences.filter(s => s.version === versionId);
    
    if (versionSentences.length === 0) {
      return 0;
    }

    // Find the index of the last read sentence
    const sentenceIndex = versionSentences.findIndex(s => s.sentenceId === lastSentenceId);
    if (sentenceIndex === -1) {
      return 0;
    }

    // Calculate percentage based on sentence position
    const progress = ((sentenceIndex + 1) / versionSentences.length) * 100;
    return Math.min(100, Math.max(0, progress));
  }

  /**
   * Sets reading progress based on percentage and updates the corresponding sentence position.
   * This allows the progress bar to control the reading position.
   * @param bookId The ID of the book
   * @param versionId The version ID  
   * @param progressPercentage Progress percentage (0-100)
   */
  public setReadingProgressPercentage(bookId: number, versionId: number, progressPercentage: number): void {
    // Save the scroll percentage directly
    this.setLastReadScrollPercentage(bookId, versionId, progressPercentage);

    // Also calculate and save the corresponding sentence position for backward compatibility
    const { bookData } = this.getBookContentById(bookId);
    const versionSentences = bookData.sentences.filter(s => s.version === versionId).sort((a, b) => a.sentenceId - b.sentenceId);
    
    if (versionSentences.length === 0) {
      return;
    }

    // Calculate which sentence corresponds to this progress percentage
    const clampedProgress = Math.min(100, Math.max(0, progressPercentage));
    const sentenceIndex = Math.floor((clampedProgress / 100) * versionSentences.length);
    const targetIndex = Math.min(sentenceIndex, versionSentences.length - 1);
    
    if (versionSentences[targetIndex]) {
      this.setLastReadPosition(bookId, versionId, versionSentences[targetIndex].sentenceId);
    }
  }

  /**
   * Gets the total reading time across all versions.
   * @param bookId The ID of the book
   * @returns Total reading time in seconds
   */
  public getTotalReadingTime(bookId: number): number {
    const readerMetadata = this.getReaderMetadata(bookId);
    return readerMetadata ? readerMetadata.readTime : 0;
  }
}

export default new BookCacheService();